# Planet Zephyria Universe

```{r}
# code for solving task

# --- 1. Atomic Types ---
# Numeric variables
gravity <- 9.8           # m/s^2
temperature <- -75.4     # Celsius
diameter <- 13450.2      # km
atmosphere_density <- 0.9  # Relative to Earth
```
```{r}
# code for solving task

# Integer variables
num_moons <- 3
num_species <- 127
crystal_mountains <- 21
```
```{r}
# code for solving task
# Logical variables
has_water <- TRUE
is_inhabited <- FALSE
```

```{r}
# code for solving task
# Character variables
planet_name <- "Zephyria"
galactic_region <- "Omega Quadrant"
planet_type <- "Terra-like"
```
```{r}
# code for solving task
# Description
cat("Planet", planet_name, "is a", planet_type, "located in the", galactic_region,
    ". It has", num_moons, "moons and", num_species, "known species.",
    "Water present:", has_water, "| Inhabited:", is_inhabited, "\n\n")
```
```{r}
# code for solving task
# --- 2. Vectors ---
# Combine all numeric/integer values
numeric_vector <- c(gravity, temperature, diameter, atmosphere_density,
                    num_moons, num_species, crystal_mountains)

# Sequence vector: 20 to 100 by 10
sequence_vector <- seq(20, 100, by = 10)

# Logical vector of 10 random TRUE/FALSE values
set.seed(123)  # For reproducibility
logical_vector <- sample(c(TRUE, FALSE), size = 10, replace = TRUE)

# Display
cat("Numeric vector:\n"); print(numeric_vector)
cat("\nSequence vector:\n"); print(sequence_vector)
cat("\nLogical vector:\n"); print(logical_vector)
cat("\n\n")

```
```{r}
# code for solving task
# --- 3. Matrix ---
# 3x3 matrix of random integers between -50 and 50
planet_matrix <- matrix(sample(-50:50, 9, replace = TRUE), nrow = 3, ncol = 3,
                        dimnames = list(
                          c("Flora", "Fauna", "Terrain"),
                          c("ZoneA", "ZoneB", "ZoneC")
                        ))

# Row and column means
row_avg <- rowMeans(planet_matrix)
col_avg <- colMeans(planet_matrix)

# Display
cat("Planet Matrix:\n")
print(planet_matrix)
cat("\nRow Means:\n"); print(row_avg)
cat("\nColumn Means:\n"); print(col_avg)
cat("\n\n")
```
```{r}
# code for solving task
# --- 4. List ---
zephyria_universe <- list(
  # Atomic types
  gravity = gravity,
  temperature = temperature,
  diameter = diameter,
  atmosphere_density = atmosphere_density,
  num_moons = num_moons,
  num_species = num_species,
  crystal_mountains = crystal_mountains,
  has_water = has_water,
  is_inhabited = is_inhabited,
  planet_name = planet_name,
  galactic_region = galactic_region,
  planet_type = planet_type,

  # Vectors
  numeric_vector = numeric_vector,
  sequence_vector = sequence_vector,
  logical_vector = logical_vector,

  # Matrix
  matrix = planet_matrix,

  # Description
  description = "Zephyria is a mysterious, frozen exoplanet with unique ecosystems and towering crystal mountains."
)

cat("Universe List Structure:\n")
str(zephyria_universe)
cat("\n\n")
```
```{r}
# code for solving task
# --- 5. Factor ---
tech_levels <- factor(c("low", "medium", "high", "low", "medium", "high", "medium"),
                      levels = c("low", "medium", "high"))

cat("Technology Levels:\n")
print(table(tech_levels))
cat("\n\n")
```
```{r}
# code for solving task
# --- 6. Data Frame ---
species_df <- data.frame(
  species_name = c("Zarnok", "Veliri", "Quarn", "Tekk", "Morith", "Slytherix"),
  avg_height_m = c(2.1, 1.3, 2.5, 1.9, 0.8, 2.8),
  is_bipedal = c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE),
  tech_level = factor(c("medium", "high", "low", "high", "low", "medium"),
                      levels = c("low", "medium", "high"))
)

# Rename columns
colnames(species_df) <- c("Name", "Height_m", "Bipedal", "Tech_Level")

# Add derived column
species_df$Is_Tall <- species_df$Height_m > 2

# Display structure and summary
cat("Species Data Frame Structure:\n")
str(species_df)
cat("\nSummary:\n")
print(summary(species_df))
cat("\nFinal Data Frame:\n")
print(species_df)
```


# Task 2: Subsetting & Missing Data


```{r}
# --- 2.1 Querying Vectors ---

## 2.1.1 From your Sequence vector
cat("3rd element of sequence_vector:\n")
print(sequence_vector[3])

cat("\nElements 2 through 5 of sequence_vector:\n")
print(sequence_vector[2:5])

cat("\nAll values > 50 in sequence_vector:\n")
print(sequence_vector[sequence_vector > 50])


## 2.1.2 From your Logical vector
cat("\nOnly TRUE values from logical_vector:\n")
print(logical_vector[logical_vector])

cat("\nIndices of TRUE values (using which):\n")
print(which(logical_vector))
```
```{r}
# --- 2.2 Querying Your “Universe” List ---

cat("\nDescription (using $ operator):\n")
print(zephyria_universe$description)

cat("\n3x3 Matrix (using [[ ]]):\n")
print(zephyria_universe[[ "matrix" ]])

cat("\nSecond element from the vector inside the list (sequence_vector[2]):\n")
print(zephyria_universe$sequence_vector[2])
```
```{r}
# --- 2.3 Investigating Your Data Frame ---

# Create a small Zephyria data frame
zephyria_df <- data.frame(
  region = c("North", "South", "East", "West", "Central"),
  population = c(500, 1200, 800, 150, 2300),
  avg_temp = c(-70, -60, -80, -75, -65),
  is_habitable = c(FALSE, TRUE, FALSE, FALSE, TRUE)
)

cat("\nFirst 3 rows of zephyria_df:\n")
print(head(zephyria_df, 3))

cat("\nValue from 4th row, 1st column:\n")
print(zephyria_df[4, 1])

cat("\nLogical column (is_habitable):\n")
print(zephyria_df$is_habitable)

# Logical subsetting
cat("\nSubset: rows with population > 1000\n")
df_subset <- zephyria_df[zephyria_df$population > 1000, ]
print(df_subset)

# Subsetting by category
cat("\nSubset: rows from North and West regions\n")
df_subset_2 <- zephyria_df[zephyria_df$region %in% c("North", "West"), ]
print(df_subset_2)
```
```{r}
# --- 2.4 Handling “Corrupted” Data (NA) ---

# Create a copy
df_corrupted <- zephyria_df

# Introduce 3 NAs
df_corrupted[2, 2] <- NA
df_corrupted[4, 3] <- NA
df_corrupted[5, 4] <- NA

cat("\nCorrupted data frame:\n")
print(df_corrupted)

# Count total missing values
cat("\nTotal missing values:\n")
print(sum(is.na(df_corrupted)))

# Count missing values per column
cat("\nMissing values per column:\n")
print(colSums(is.na(df_corrupted)))

# Mean of numeric column with NA
cat("\nMean of 'population' (ignoring NA):\n")
print(mean(df_corrupted$population, na.rm = TRUE))

# Remove rows with NAs
cat("\nClean data frame (rows without NA):\n")
df_clean <- na.omit(df_corrupted)
print(df_clean)
```
```{r}
# --- 2.5 Bonus Challenge: which() ---

cat("\nRow with highest population:\n")
highest_pop_index <- which.max(zephyria_df$population)
print(zephyria_df[highest_pop_index, ])

cat("\nRow with lowest population:\n")
lowest_pop_index <- which.min(zephyria_df$population)
print(zephyria_df[lowest_pop_index, ])
```
